
/*本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印
*****
 ***
  *
 ***
*****
所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，
再从小到大顺序递增；首尾符号数相等。
给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。
输入格式：
输入在一行给出1个正整数N（<=1000）和一个符号，中间以空格分隔。
输出格式：
首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。
输入样例：
19 *
输出样例：
*****
 ***
  *
 ***
*****
2
*/


/*
#include<stdio.h>
int main()
{
    char n;
    scanf("%c",&n);
    int i;
    int x=0;
    i=n/2+1;
    while(i=1)
    {
        i-=2;
        x++;
    }
    int j;
    for(j=0;j<x;j++)
    {
        printf("%c",*);
    }
    return 0;
}
*/





/*注意第一个测试。这些书得到的数字1,2,3,4,5,6,7,8,9,10,11,12,13，总共17位数字。

请注意第二个示例。这些书获得数字1,2,3,4，总数为4位数字。
*/
/*
#include<stdio.h>
int main()
{
         int n;
         scanf("%d",&n);
         int x;
         int i;
         int sum=0;
        for(x=n,i=0;n!=0;n--)
        {
                 while(x)
                 {
                    x/=10;
                 i++;
                 }

                 sum+=i;



        }
        printf("%d",sum);
        return 0;
}*/
/*
#include<stdio.h>
int main()
{
         int n;
         scanf("%d",&n);
         int x;
         int i=0;
         int sum=0;
         for(x=n;n!=0;n--)
         {
                  x/=10;
                  i++;
                  sum+=i;
                  i=0;
         }
         printf("%d",sum);
         return 0;



}*/

/*
题目标题: 高斯日记
大数学家高斯有个好习惯：无论如何都要记日记。
    他的日记有个与众不同的地方，他从不注明年月日，
    而是用一个整数代替，比如：4210
    后来人们知道，那个整数就是日期，它表示那一天是高斯出生后的第几天。
    这或许也是个好习惯，它时时刻刻提醒着主人：日子又过去一天，还有多少时光
    可以用于浪费呢？
    高斯出生于：1777年4月30日。
    在高斯发现的一个重要定理的日记上标注着：5343，因此可算出那天是：
    1791年12月15日。
    高斯获得博士学位的那天日记上标着：8113
    请你算出高斯获得博士学位的年月日。
提交答案的格式是：yyyy-mm-dd, 例如：1980-03-21*/
/*
#include<stdio.h>
int main()
{
         int x;
         scanf("%d",&x);
         int n=1777;
         int yue=4;
         int nian;
         nian=x/365;
         n=n+nian;
         int i;
         i=x-(365*nian);
         int a=5;
         int b;
         if(i>30)
         {


         switch(a)
         {
                  case 5:yue+=1;
                  i-=31;
                  case 6:yue+=1;
                  i-=30;
                  case 7:yue+=1;
                  i-=31;
                  case 8:yue+=1;
                  i-=31;
                  case 9:yue+=1;
                  i-=30;
                 case 10:yue+=1;
                 i-=31;
                 case 11:yue+=1;
                 i-=30;
                 case 12:yue+=1;
                 i-=31;

         }
         a+=1;


         }
         else
                  b=i;



         printf("%d-%d-%d",n,yue,b);
         return 0;

}*/


/*
标题: 马虎的算
小明是个急性子，上小学的时候经常把老师写在黑板上的题目抄错了。
有一次，老师出的题目是：36 x 495 = ?
他却给抄成了：396 x 45 =
但结果却很戏剧性，他的答案竟然是对的！！
因为 36 * 495 = 396 * 45 = 17820
类似这样的巧合情况可能还有很多，比如：27 * 594 = 297 * 54
假设 a b c d e 代表1~9不同的5个数字（注意是各不相同的数字，且不含0）
能满足形如： ab * cde = adb * ce 这样的算式一共有多少种呢？
请你利用计算机的优势寻找所有的可能，并回答不同算式的种类数。
满足乘法交换律的算式计为不同的种类，所以答案肯定是个偶数。
*/
/*
#include<stdio.h>
int main()
{
         int a,b,c,d,e;
         int n,m,j,k;
         int x=0;
         for(a=1;a<10;a++)
         {
                  for(b=1;b<10;b++)
                  {
                           for(c=1;c<10;c++)
                           {
                                    for(d=1;d<10;d++)
                                    {
                                             for(e=1;e<10;e++)
                                             {
                                                      if(a!=b&&a!=c&&a!=d&&a!=e&&b!=c&b!=d&&b!=e&&c!=d&&c!=e&d!=e)
                                                      {
                                                               n=a*10+b;
                                                               m=c*100+d*10+e;
                                                               j=a*100+d*10+b;
                                                               k=c*10+e;
                                                               if(n*m==j*k)
                                                               {
                                                                        x++;
                                                               }
                                                      }
                                             }
                                    }
                           }
                  }
         }
         printf("%d",x);
         return 0;
}*/



/*标题: 黄金连分数
黄金分割数0.61803... 是个无理数，这个常数十分重要
，在许多工程问题中会出现。有时需要把这个数字求得很精确。
对于某些精密工程，常数的精度很重要。也许你听说过哈勃太空望远镜，它首次
升空后就发现了一处人工加工错误，对那样一个庞然大物，其实
只是镜面加工时有比头发丝还细许多倍的一处错误而已，却使它成了“近视眼”!!
言归正传，我们如何求得黄金分割数的尽可能精确的值呢？有许多方法。
比较简单的一种是用连分数：
                  1
    黄金数 = ---------------------
                        1
             1 + -----------------
                          1
                 1 + -------------
                            1
                     1 + ---------
                          1 + ...
这个连分数计算的“层数”越多，它的值越接近黄金分割数。
请你利用这一特性，求出黄金分割数的足够精确值
，要求四舍五入到小数点后100位。
小数点后3位的值为：0.618
小数点后4位的值为：0.6180
小数点后5位的值为：0.61803
小数点后7位的值为：0.6180340
（注意尾部的0，不能忽略）
你的任务是：写出精确到小数点后100位精度的黄金分割值。
注意：尾数的四舍五入！ 尾数是0也要保留1
*/


//输入T，n，a   输出b c
#include<stdio.h>
int main()
{
         int t;
         scanf("%d",&t);
         int n,a;
         int k;

         for(k=0;k<t;k++)
         {
            scanf("%d %d",&n,&a);
         }
         if(a>=3)
         {
                int b,c;
         int i,j;
         int a1;
         int b1;
         int c1;
        a1=pow(a,n);
        for(i=1;i<10;i++)
        {
                 for(j=1;j<10;j++)
                 {

                       if(pow(i,n)-pow(j,n)==a1)


                               b1=i;
                          c1=j;

                         break;
                 }






        }



     printf("%d %d",b1,c1);

         }



         return 0;



}















/*
#include<stdio.h>
int main()
{
         int t;
         scanf("%d",&t);
         int n,a;
         int k;
         for(k=0;k<t;k++)
         {
            scanf("%d %d",&n,&a);
         }

         int b,c;
         int i,j;
         int a1;
         int b1;
         int c1;
        a1=pow(a,n);
        if(n>=3&&a<=40000)
        {
              for(i=1;i<10;i++)
        {
                 for(j=1;j<10;j++)
                 {


                          if(a1+pow(i,n)==pow(j,n));
                          {

                              b1=i;
                              c1=j;
                           break;
                          }



                 }
        }




         printf("%d %d",b1,c1);
        }

         return 0;







}
*/



